// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package suppliers

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/ascenmmo/websocket-server/clients/suppliers/cb"
	"github.com/ascenmmo/websocket-server/clients/suppliers/hasher"
	"github.com/ascenmmo/websocket-server/clients/suppliers/jsonrpc"
)

type ClientJsonRPC struct {
	name string

	rpc     *jsonrpc.ClientRPC
	rpcOpts []jsonrpc.Option

	cache cache

	cbCfg cb.Settings
	cb    *cb.CircuitBreaker

	fallbackTTL            time.Duration
	fallbackServerSettings fallbackServerSettings

	errorDecoder ErrorDecoder
}

func New(endpoint string, opts ...Option) (cli *ClientJsonRPC) {

	hostname, _ := os.Hostname()
	cli = &ClientJsonRPC{
		errorDecoder: defaultErrorDecoder,
		fallbackTTL:  time.Hour * 24,
		name:         hostname + "_" + "github.com/ascenmmo/websocket-server",
	}
	cli.applyOpts(opts)
	cli.rpc = jsonrpc.NewClient(endpoint, cli.rpcOpts...)
	cli.cb = cb.NewCircuitBreaker("github.com/ascenmmo/websocket-server", cli.cbCfg)
	return
}

func (cli *ClientJsonRPC) ServerSettings() *ClientServerSettings {
	return &ClientServerSettings{ClientJsonRPC: cli}
}

func (cli *ClientJsonRPC) proceedResponse(ctx context.Context, callMethod func(request any) (response *jsonrpc.ResponseRPC, err error), request any, fallbackCheck func(error) bool, methodResponse any) (err error) {

	cacheKey, _ := hasher.Hash(request)
	err = cli.cb.Execute(func() (err error) {
		var rpcResponse *jsonrpc.ResponseRPC
		rpcResponse, err = callMethod(request)
		if rpcResponse != nil && rpcResponse.Error != nil {
			if cli.errorDecoder != nil {
				err = cli.errorDecoder(rpcResponse.Error.Raw())
			} else {
				err = fmt.Errorf(rpcResponse.Error.Message)
			}
			return
		}
		return rpcResponse.GetObject(&methodResponse)
	}, cb.IsSuccessful(func(err error) (success bool) {
		if fallbackCheck != nil {
			return fallbackCheck(err)
		}
		if success = cli.cb.IsSuccessful()(err); success {
			if cli.cache != nil && cacheKey != 0 {
				_ = cli.cache.SetTTL(ctx, strconv.FormatUint(cacheKey, 10), methodResponse, cli.fallbackTTL)
			}
		}
		return
	}), cb.Fallback(func(err error) error {
		if cli.cache != nil && cacheKey != 0 {
			_, _, err = cli.cache.GetTTL(ctx, strconv.FormatUint(cacheKey, 10), &methodResponse)
		}
		return err
	}))
	return
}
